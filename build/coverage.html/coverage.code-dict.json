{"/home/travis/build/npmtest/node-npmtest-kue/test.js":"/* istanbul instrument in package npmtest_kue */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-kue/lib.npmtest_kue.js":"/* istanbul instrument in package npmtest_kue */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_kue = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_kue = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-kue/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-kue && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_kue */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_kue\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_kue.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_kue.rollup.js'] =\n            local.assetsDict['/assets.npmtest_kue.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_kue.__dirname + '/lib.npmtest_kue.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-kue/node_modules/kue/index.js":"module.exports = require('./lib/kue');","/home/travis/build/npmtest/node-npmtest-kue/node_modules/kue/lib/kue.js":"/*!\n * kue\n * Copyright (c) 2013 Automattic <behradz@gmail.com>\n * Copyright (c) 2011 LearnBoost <tj@learnboost.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar EventEmitter = require('events').EventEmitter\n  , Worker       = require('./queue/worker')\n  , events       = require('./queue/events')\n  , Job          = require('./queue/job')\n  , Warlock      = require('node-redis-warlock')\n  , _            = require('lodash')\n  , redis        = require('./redis')\n  , noop         = function(){};\n\n/**\n * Expose `Queue`.\n */\n\nexports = module.exports = Queue;\n\n/**\n * Library version.\n */\n\nexports.version = require('../package.json').version;\n\n/**\n * Expose `Job`.\n */\n\nexports.Job = Job;\n\n/**\n * Server instance (that is lazily required)\n */\n\nvar app;\n\n/**\n * Expose the server.\n */\n\nObject.defineProperty(exports, 'app', {\n  get: function() {\n    return app || (app = require('./http'));\n  }\n});\n\n/**\n * Expose the RedisClient factory.\n */\n\nexports.redis = redis;\n\n/**\n * Create a new `Queue`.\n *\n * @return {Queue}\n * @api public\n */\n\nexports.createQueue = function( options ) {\n  if( !Queue.singleton ) {\n    Queue.singleton = new Queue(options);\n  }\n  events.subscribe();\n  return Queue.singleton;\n\n};\n\n/**\n * Store workers\n */\nexports.workers = [];\n\n/**\n * Initialize a new job `Queue`.\n *\n * @api public\n */\n\nfunction Queue( options ) {\n  options     = options || {};\n  this.name   = options.name || 'kue';\n  this.id = [ 'kue', require('os').hostname(), process.pid ].join(':');\n  this._options   = options;\n  this.promoter     = null;\n  this.workers      = exports.workers;\n  this.shuttingDown = false;\n  Job.disableSearch = options.disableSearch !== false;\n  options.jobEvents !== undefined ? Job.jobEvents = options.jobEvents : '';\n  redis.configureFactory(options, this);\n  this.client = Worker.client = Job.client = redis.createClient();\n}\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\n\nQueue.prototype.__proto__ = EventEmitter.prototype;\n\n/**\n * Create a `Job` with the given `type` and `data`.\n *\n * @param {String} type\n * @param {Object} data\n * @return {Job}\n * @api public\n */\n\nQueue.prototype.create =\n  Queue.prototype.createJob = function( type, data ) {\n    return new Job(type, data);\n  };\n\n/**\n * Proxy to auto-subscribe to events.\n *\n * @api public\n */\n\nvar on             = EventEmitter.prototype.on;\nQueue.prototype.on = function( event ) {\n  if( 0 == event.indexOf('job') ) events.subscribe();\n  return on.apply(this, arguments);\n};\n\n/**\n * Promote delayed jobs, checking every `ms`,\n * defaulting to 1 second.\n *\n * @params {Number} ms\n * @deprecated\n */\n\nQueue.prototype.promote = function( ms, l ) {\n  console.warn('promote method is deprecated, you don\\'t need to call this anymore. You can safely remove it from your code now.');\n};\n\n/**\n * sets up promotion & ttl timers\n */\n\nQueue.prototype.setupTimers = function() {\n  if( this.warlock === undefined ) {\n    this.lockClient = redis.createClient();\n    this.warlock    = new Warlock(this.lockClient);\n  }\n  this.checkJobPromotion(this._options.promotion);\n  this.checkActiveJobTtl(this._options.promotion);\n};\n\n/**\n * This new method is called by Kue when created\n *\n * Promote delayed jobs, checking every `ms`,\n * defaulting to 1 second.\n *\n * @params {Number} ms\n */\n\nQueue.prototype.checkJobPromotion = function( promotionOptions ) {\n  promotionOptions = promotionOptions || {};\n  var client       = this.client\n    , self         = this\n    , timeout      = promotionOptions.interval || 1000\n    , lockTtl      = 2000\n      //, lockTtl = timeout\n    , limit        = promotionOptions.limit || 1000;\n  clearInterval(this.promoter);\n  this.promoter    = setInterval(function() {\n    self.warlock.lock('promotion', lockTtl, function( err, unlock ) {\n      if( err ) {\n        // Something went wrong and we weren't able to set a lock\n        self.emit('error', err);\n        return;\n      }\n      if( typeof unlock === 'function' ) {\n        // If the lock is set successfully by this process, an unlock function is passed to our callback.\n        client.zrangebyscore(client.getKey('jobs:delayed'), 0, Date.now(), 'LIMIT', 0, limit, function( err, ids ) {\n          if( err || !ids.length ) return unlock();\n          //TODO do a ZREMRANGEBYRANK jobs:delayed 0 ids.length-1\n          var doUnlock = _.after(ids.length, unlock);\n          ids.forEach(function( id ) {\n            id = client.stripFIFO(id);\n            Job.get(id, function( err, job ) {\n              if( err ) return doUnlock();\n              events.emit(id, 'promotion');\n              job.inactive(doUnlock);\n            });\n          });\n        });\n      } else {\n        // The lock was not established by us, be silent\n      }\n    });\n  }, timeout);\n};\n\n\nQueue.prototype.checkActiveJobTtl = function( ttlOptions ) {\n  ttlOptions              = ttlOptions || {};\n  var client              = this.client\n    , self                = this\n    , timeout             = ttlOptions.interval || 1000\n    , lockTtl             = 2000\n    , limit               = ttlOptions.limit || 1000;\n  clearInterval(this.activeJobsTtlTimer);\n  this.activeJobsTtlTimer = setInterval(function() {\n    self.warlock.lock('activeJobsTTL', lockTtl, function( err, unlock ) {\n      if( err ) {\n        // Something went wrong and we weren't able to set a lock\n        self.emit('error', err);\n        return;\n      }\n      if( typeof unlock === 'function' ) {\n        // If the lock is set successfully by this process, an unlock function is passed to our callback.\n        // filter only jobs set with a ttl (timestamped) between a large number and current time\n        client.zrangebyscore(client.getKey('jobs:active'), 100000, Date.now(), 'LIMIT', 0, limit, function( err, ids ) {\n          if( err || !ids.length ) return unlock();\n\n          var idsRemaining = ids.slice();\n          var doUnlock = _.after(ids.length, function(){\n            self.removeAllListeners( 'job ttl exceeded ack' );\n            waitForAcks && clearTimeout( waitForAcks );\n            unlock && unlock();\n          });\n\n          self.on( 'job ttl exceeded ack', function( id ) {\n            idsRemaining.splice( idsRemaining.indexOf( id ), 1 );\n            doUnlock();\n          });\n\n          var waitForAcks = setTimeout( function(){\n            idsRemaining.forEach( function( id ){\n              id = client.stripFIFO(id);\n              Job.get(id, function( err, job ) {\n                if( err ) return doUnlock();\n                job.failedAttempt( { error: true, message: 'TTL exceeded' }, doUnlock );\n              });\n            });\n          }, 1000 );\n\n          ids.forEach(function( id ) {\n            id = client.stripFIFO(id);\n            events.emit(id, 'ttl exceeded');\n          });\n        });\n      } else {\n        // The lock was not established by us, be silent\n      }\n    });\n  }, timeout);\n};\n\n/**\n * Runs a LUA script to diff inactive jobs ZSET cardinality\n * and helper pop LIST length each `ms` milliseconds and syncs helper LIST.\n *\n * @param {Number} ms interval for periodical script runs\n * @api public\n */\n\nQueue.prototype.watchStuckJobs = function( ms ) {\n  var client = this.client\n    , self   = this\n    , ms     = ms || 1000;\n  var prefix = this.client.prefix;\n\n  if( this.client.constructor.name == 'Redis'  || this.client.constructor.name == 'Cluster') {\n    // {prefix}:jobs format is needed in using ioredis cluster to keep they keys in same node\n    prefix = '{' + prefix + '}';\n  }\n  var script =\n        'local msg = redis.call( \"keys\", \"' + prefix + ':jobs:*:inactive\" )\\n\\\n        local need_fix = 0\\n\\\n        for i,v in ipairs(msg) do\\n\\\n          local queue = redis.call( \"zcard\", v )\\n\\\n          local jt = string.match(v, \"' + prefix + ':jobs:(.*):inactive\")\\n\\\n          local pending = redis.call( \"LLEN\", \"' + prefix + ':\" .. jt .. \":jobs\" )\\n\\\n          if queue > pending then\\n\\\n            need_fix = need_fix + 1\\n\\\n            for j=1,(queue-pending) do\\n\\\n              redis.call( \"lpush\", \"' + prefix + ':\"..jt..\":jobs\", 1 )\\n\\\n            end\\n\\\n          end\\n\\\n        end\\n\\\n        return need_fix';\n  clearInterval(this.stuck_job_watch);\n  client.script('LOAD', script, function( err, sha ) {\n    if( err ) {\n      return self.emit('error', err);\n    }\n    this.stuck_job_watch = setInterval(function() {\n      client.evalsha(sha, 0, function( err, fixes ) {\n        if( err ) return clearInterval(this.stuck_job_watch);\n      }.bind(this));\n    }.bind(this), ms);\n\n  }.bind(this));\n};\n\n/**\n * Get setting `name` and invoke `fn(err, res)`.\n *\n * @param {String} name\n * @param {Function} fn\n * @return {Queue} for chaining\n * @api public\n */\n\nQueue.prototype.setting = function( name, fn ) {\n  fn = fn || noop;\n  this.client.hget(this.client.getKey('settings'), name, fn);\n  return this;\n};\n\n/**\n * Process jobs with the given `type`, invoking `fn(job)`.\n *\n * @param {String} type\n * @param {Number|Function} n\n * @param {Function} fn\n * @api public\n */\n\nQueue.prototype.process = function( type, n, fn ) {\n  var self = this;\n\n  if( 'function' == typeof n ) fn = n, n = 1;\n\n  while( n-- ) {\n    var worker = new Worker(this, type).start(fn);\n    worker.id  = [ self.id, type, self.workers.length + 1 ].join(':');\n    worker.on('error', function( err ) {\n      self.emit('error', err);\n    });\n    worker.on('job complete', function( job ) {\n      // guard against emit after shutdown\n      if( self.client ) {\n        self.client.incrby(self.client.getKey('stats:work-time'), job.duration, noop);\n      }\n    });\n    // Save worker so we can access it later\n    self.workers.push(worker);\n  }\n  this.setupTimers();\n};\n\n/**\n * Graceful shutdown\n *\n * @param {Number} timeout in milliseconds to wait for workers to finish\n * @param {String} type specific worker type to shutdown\n * @param {Function} fn callback\n * @return {Queue} for chaining\n * @api public\n */\n\nQueue.prototype.shutdown = function( timeout, type, fn ) {\n  var self = this\n    , n    = self.workers.length;\n  if( arguments.length === 1 ) {\n    fn      = timeout;\n    type    = '';\n    timeout = null;\n  } else if( arguments.length === 2 ) {\n    fn   = type;\n    type = '';\n  }\n  var origFn = fn || function() {\n    };\n\n  if( this.shuttingDown && type === '' ) { // a global shutdown already has been called\n    return fn(new Error('Shutdown already in progress'));\n  }\n\n  if( type === '' ) { // this is a global shutdown call\n    this.shuttingDown = true;\n  }\n\n  var cleanup = function() {\n    if( self.shuttingDown ) {\n      self.workers    = [];\n      exports.workers = [];\n      self.removeAllListeners();\n      Queue.singleton = null;\n      events.unsubscribe();\n      // destroy redis client and pubsub\n      redis.reset();\n      self.client && self.client.quit();\n      self.client = null;\n      self.lockClient && self.lockClient.quit();\n      self.lockClient = null;\n    }\n  };\n\n  // Wrap `fn` to only call after all workers finished\n  fn = function( err ) {\n    if( err ) {\n      return origFn(err);\n    }\n    if( !--n ) {\n      cleanup();\n      origFn.apply(null, arguments);\n    }\n  };\n\n  // shut down promoter interval\n  if( self.shuttingDown ) {\n    if( self.promoter ) {\n      clearInterval(self.promoter);\n      self.promoter = null;\n    }\n    if( self.activeJobsTtlTimer ) {\n      clearInterval(self.activeJobsTtlTimer);\n      self.activeJobsTtlTimer = null;\n    }\n\n  }\n\n  if( !self.workers.length ) {\n    cleanup();\n    origFn();\n  } else {\n    // Shut down workers 1 by 1\n    self.workers.forEach(function( worker ) {\n      if( self.shuttingDown || worker.type == type ) {\n        worker.shutdown(timeout, fn);\n      } else {\n        fn && fn();\n      }\n    });\n  }\n\n  return this;\n};\n\n/**\n * Get the job types present and callback `fn(err, types)`.\n *\n * @param {Function} fn\n * @return {Queue} for chaining\n * @api public\n */\n\nQueue.prototype.types = function( fn ) {\n  fn = fn || noop;\n  this.client.smembers(this.client.getKey('job:types'), fn);\n  return this;\n};\n\n/**\n * Return job ids with the given `state`, and callback `fn(err, ids)`.\n *\n * @param {String} state\n * @param {Function} fn\n * @return {Queue} for chaining\n * @api public\n */\n\nQueue.prototype.state = function( state, fn ) {\n  var self = this;\n  this.client.zrange(this.client.getKey('jobs:' + state), 0, -1, function(err,ids){\n    var fixedIds = [];\n    ids.forEach(function(id){\n        fixedIds.push(self.client.stripFIFO(id));\n      });\n    fn(err,fixedIds);\n  });\n  return this;\n};\n\n/**\n * Get queue work time in milliseconds and invoke `fn(err, ms)`.\n *\n * @param {Function} fn\n * @return {Queue} for chaining\n * @api public\n */\n\nQueue.prototype.workTime = function( fn ) {\n  this.client.get(this.client.getKey('stats:work-time'), function( err, n ) {\n    if( err ) return fn(err);\n    fn(null, parseInt(n, 10));\n  });\n  return this;\n};\n\n/**\n * Get cardinality of jobs with given `state` and `type` and callback `fn(err, n)`.\n *\n * @param {String} type\n * @param {String} state\n * @param {Function} fn\n * @return {Queue} for chaining\n * @api public\n */\n\nQueue.prototype.cardByType = function( type, state, fn ) {\n  fn = fn || noop;\n  this.client.zcard(this.client.getKey('jobs:' + type + ':' + state), fn);\n  return this;\n};\n\n/**\n * Get cardinality of `state` and callback `fn(err, n)`.\n *\n * @param {String} state\n * @param {Function} fn\n * @return {Queue} for chaining\n * @api public\n */\n\nQueue.prototype.card = function( state, fn ) {\n  fn = fn || noop;\n  this.client.zcard(this.client.getKey('jobs:' + state), fn);\n  return this;\n};\n\n/**\n * Completed jobs.\n * @param {Function} fn\n * @return {Queue} for chaining\n * @api public\n */\n\nQueue.prototype.complete = function( fn ) {\n  return this.state('complete', fn);\n};\n\n/**\n * Failed jobs.\n * @param {Function} fn\n * @return {Queue} for chaining\n * @api public\n */\n\nQueue.prototype.failed = function( fn ) {\n  return this.state('failed', fn);\n};\n\n/**\n * Inactive jobs (queued).\n * @param {Function} fn\n * @return {Queue} for chaining\n * @api public\n */\n\nQueue.prototype.inactive = function( fn ) {\n  return this.state('inactive', fn);\n};\n\n/**\n * Active jobs (mid-process).\n * @param {Function} fn\n * @return {Queue} for chaining\n * @api public\n */\n\nQueue.prototype.active = function( fn ) {\n  return this.state('active', fn);\n};\n\n/**\n * Delayed jobs.\n * @param {Function} fn\n * @return {Queue} for chaining\n * @api public\n */\n\nQueue.prototype.delayed = function( fn ) {\n  return this.state('delayed', fn);\n};\n\n/**\n * Completed jobs of type `type` count.\n * @param {String} type is optional\n * @param {Function} fn\n * @return {Queue} for chaining\n * @api public\n */\n\nQueue.prototype.completeCount = function( type, fn ) {\n  if( 1 == arguments.length ) {\n    fn = type;\n    return this.card('complete', fn);\n  }\n  return this.cardByType(type, 'complete', fn);\n};\n\n\n/**\n * Failed jobs of type `type` count.\n * @param {String} type is optional\n * @param {Function} fn\n * @return {Queue} for chaining\n * @api public\n */\n\nQueue.prototype.failedCount = function( type, fn ) {\n  if( 1 == arguments.length ) {\n    fn = type;\n    return this.card('failed', fn);\n  }\n  return this.cardByType(type, 'failed', fn);\n};\n\n/**\n * Inactive jobs (queued) of type `type` count.\n * @param {String} type is optional\n * @param {Function} fn\n * @return {Queue} for chaining\n * @api public\n */\n\nQueue.prototype.inactiveCount = function( type, fn ) {\n  if( 1 == arguments.length ) {\n    fn = type;\n    return this.card('inactive', fn);\n  }\n  return this.cardByType(type, 'inactive', fn);\n};\n\n/**\n * Active jobs (mid-process) of type `type` count.\n * @param {String} type is optional\n * @param {Function} fn\n * @return {Queue} for chaining\n * @api public\n */\n\nQueue.prototype.activeCount = function( type, fn ) {\n  if( 1 == arguments.length ) {\n    fn = type;\n    return this.card('active', fn);\n  }\n  return this.cardByType(type, 'active', fn);\n};\n\n/**\n * Delayed jobs of type `type` count.\n * @param {String} type is optional\n * @param {Function} fn\n * @return {Queue} for chaining\n * @api public\n */\n\nQueue.prototype.delayedCount = function( type, fn ) {\n  if( 1 == arguments.length ) {\n    fn = type;\n    return this.card('delayed', fn);\n  }\n  return this.cardByType(type, 'delayed', fn);\n};\n\n/**\n * Test mode for convenience in test suites\n * @api public\n */\n\nQueue.prototype.testMode = require('./queue/test_mode');\n","/home/travis/build/npmtest/node-npmtest-kue/node_modules/kue/lib/queue/worker.js":"/*!\n * kue - Worker\n * Copyright (c) 2013 Automattic <behradz@gmail.com>\n * Copyright (c) 2011 LearnBoost <tj@learnboost.com>\n * MIT Licensed\n * Author: behradz@gmail.com\n */\n\n/**\n * Module dependencies.\n */\n\nvar EventEmitter = require('events').EventEmitter\n  , redis        = require('../redis')\n  , events       = require('./events')\n  , Job          = require('./job')\n  , noop         = function() {};\n\n/**\n * Expose `Worker`.\n */\n\nmodule.exports = Worker;\n\n/**\n * Redis connections used by `getJob()` when blocking.\n */\n\nvar clients = {};\n\n/**\n * Initialize a new `Worker` with the given Queue\n * targetting jobs of `type`.\n *\n * @param {Queue} queue\n * @param {String} type\n * @api private\n */\n\nfunction Worker( queue, type ) {\n  this.queue   = queue;\n  this.type    = type;\n  this.client  = Worker.client || (Worker.client = redis.createClient());\n  this.running = true;\n  this.job     = null;\n}\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\n\nWorker.prototype.__proto__ = EventEmitter.prototype;\n\n/**\n * Start processing jobs with the given `fn`,\n *\n * @param {Function} fn\n * @return {Worker} for chaining\n * @api private\n */\n\nWorker.prototype.start = function( fn ) {\n  var self = this;\n  self.idle();\n  if( !self.running ) return;\n  this.queue.removeAllListeners('job ttl exceeded');\n\n  /*\n   listen if current job ttl received,\n   so that this worker can fail current stuck job and continue,\n   in case user's process callback is stuck and done is not called in time\n   */\n  this.queue.on( 'job ttl exceeded', function( id ) {\n    if( this.job && this.job.id && this.job.id === id ) {\n      //this.start(fn);\n      this.failed( this.job, { error: true, message: 'TTL exceeded' }, fn );\n      events.emit(id, 'ttl exceeded ack');\n    }\n  }.bind( this ));\n\n  self.getJob(function( err, job ) {\n    if( err ) self.error(err, job);\n    if( !job || err ) return process.nextTick(function() {\n      self.start(fn);\n    });\n    self.process(job, fn);\n  });\n  return this;\n};\n\n/**\n * Error handler, currently does nothing.\n *\n * @param {Error} err\n * @param {Job} job\n * @return {Worker} for chaining\n * @api private\n */\n\nWorker.prototype.error = function( err, job ) {\n  this.emit('error', err, job);\n  return this;\n};\n\n/**\n * Process a failed `job`. Set's the job's state\n * to \"failed\" unless more attempts remain, in which\n * case the job is marked as \"inactive\" or \"delayed\"\n * and remains in the queue.\n *\n * @param {Job} job\n * @param {Object} theErr\n * @param {Function} fn\n * @return {Worker} for chaining\n * @api private\n */\n\nWorker.prototype.failed = function( job, theErr, fn ) {\n  var self = this;\n  job.failedAttempt( theErr, function( err, hasAttempts, attempt ) {\n    if( err ) return self.error(err, job);\n    if( hasAttempts ) {\n      self.emitJobEvent( 'failed attempt', job, theErr.message || theErr.toString(), attempt );\n    } else {\n      self.emitJobEvent( 'failed', job, theErr.message || theErr.toString() );\n    }\n    fn && self.start(fn);\n  });\n  return this;\n};\n\n/**\n * Process `job`, marking it as active,\n * invoking the given callback `fn(job)`,\n * if the job fails `Worker#failed()` is invoked,\n * otherwise the job is marked as \"complete\".\n *\n * @param {Job} job\n * @param {Function} fn\n * @return {Worker} for chaining\n * @api public\n */\n\nWorker.prototype.process = function( job, fn ) {\n  var self  = this\n    , start = new Date();\n\n  this.job = job;\n  job.set( 'started_at', job.started_at = start.getTime() );\n  job.set( 'workerId', job.workerId = this.id );\n  /*\n  store job.id around given done to the caller,\n  so that we can later match against it when done is called\n   */\n  var createDoneCallback = function( jobId ) {\n    return function( err, result ) {\n      if( self.drop_user_callbacks ) {\n        //console.warn( 'Worker started to shutdown, ignoring execution of done callback' );\n        //job.log( 'Worker started to shutdown, ignoring execution of done callback' );\n        return;\n      }\n      /*\n      if no job in hand, or the current job in hand\n      doesn't match called done callback's jobId\n      then ignore running callers done.\n       */\n      if( self.job === null || self.job && self.job.id && self.job.id !== jobId ) {\n        //console.warn( 'This job has already been finished, ignoring execution of done callback' );\n        //job.log( 'This job has already been finished, ignoring execution of done callback' );\n        return;\n      }\n      if( err ) {\n        return self.failed(job, err, fn);\n      }\n      job.set('duration', job.duration = new Date - start);\n      if( result ) {\n        try {\n          job.result = result;\n          job.set('result', JSON.stringify(result), noop);\n        } catch(e) {\n          job.set('result', JSON.stringify({ error: true, message: 'Invalid JSON Result: \"' + result + '\"' }), noop);\n        }\n      }\n      job.complete(function() {\n        job.attempt(function() {\n          if( job.removeOnComplete() ) {\n            job.remove();\n          }\n          self.emitJobEvent('complete', job, result);\n          self.start(fn);\n        });\n      }.bind(this));\n    };\n  };\n\n  var doneCallback = createDoneCallback( job.id );\n\n  var workerCtx    = {\n    /**\n     * @author behrad\n     * @pause: let the processor to tell worker not to continue processing new jobs\n     */\n    pause: function( timeout, fn ) {\n      if( arguments.length === 1 ) {\n        fn      = timeout;\n        timeout = 5000;\n      }\n      self.queue.shutdown(Number(timeout), self.type, fn);\n    },\n    /**\n     * @author behrad\n     * @pause: let the processor to trigger restart for they job processing\n     */\n    resume: function() {\n      if( self.resume() ) {\n        self.start(fn);\n      }\n    },\n    shutdown: function() {\n      self.shutdown();\n    }\n  };\n\n  job.active(function() {\n    self.emitJobEvent('start', job, job.type);\n    if( fn.length === 2 ) { // user provided a two argument function, doesn't need workerCtx\n      fn(job, doneCallback);\n    } else { // user wants workerCtx parameter, make done callback the last\n      fn(job, workerCtx, doneCallback);\n    }\n  }.bind(this));\n\n  return this;\n};\n\n/**\n * Atomic ZPOP implementation.\n *\n * @param {String} key\n * @param {Function} fn\n * @api private\n */\n\nWorker.prototype.zpop = function( key, fn ) {\n  this.client\n    .multi()\n    .zrange(key, 0, 0)\n    .zremrangebyrank(key, 0, 0)\n    .exec(function( err, res ) {\n      if( err || !res || !res[ 0 ] || !res[ 0 ].length ) return fn(err);\n      var id = res[ 0 ][ 0 ] || res[ 0 ][ 1 ][ 0 ];\n      fn(null, this.client.stripFIFO(id));\n    }.bind(this));\n};\n\n/**\n * Attempt to fetch the next job.\n *\n * @param {Function} fn\n * @api private\n */\n\nWorker.prototype.getJob = function( fn ) {\n  var self = this;\n  if( !self.running ) {\n    return fn('Already Shutdown');\n  }\n  // alloc a client for this job type\n  var client = clients[ self.type ] || (clients[ self.type ] = redis.createClient());\n  // BLPOP indicates we have a new inactive job to process\n  client.blpop(client.getKey(self.type + ':jobs'), 0, function( err ) {\n    if( err || !self.running ) {\n      if( self.client && self.client.connected && !self.client.closing ) {\n        self.client.lpush(self.client.getKey(self.type + ':jobs'), 1, noop);\n      }\n      return fn(err);\t\t// SAE: Added to avoid crashing redis on zpop\n    }\n    // Set job to a temp value so shutdown() knows to wait\n    self.job = true;\n    self.zpop(self.client.getKey('jobs:' + self.type + ':inactive'), function( err, id ) {\n      if( err || !id ) {\n        self.idle();\n        return fn(err /*|| \"No job to pop!\"*/);\n      }\n      Job.get(id, fn);\n    });\n  });\n};\n\n/**\n * emits worker idle event and nullifies current job in hand\n */\n\nWorker.prototype.idle = function() {\n  this.job = null;\n  this.emit('idle');\n  return this;\n};\n\n/**\n * Gracefully shut down the worker\n *\n * @param {Function} fn\n * @param {int} timeout\n * @api private\n */\n\nWorker.prototype.shutdown = function( timeout, fn ) {\n  var self = this, shutdownTimer = null;\n  if( arguments.length === 1 ) {\n    fn      = timeout;\n    timeout = null;\n  }\n\n  // Wrap `fn` so we don't pass `job` to it\n  var _fn = function( job ) {\n    if( job && self.job && job.id != self.job.id ) {\n      return; // simply ignore older job events currently being received until the right one comes...\n    }\n    shutdownTimer && clearTimeout(shutdownTimer);\n    self.removeAllListeners();\n    self.job        = null;\n    //Safeyly kill any blpop's that are waiting.\n    (self.type in clients) && clients[ self.type ].quit();\n    delete clients[ self.type ];\n    self.cleaned_up = true;\n    //fix half-blob job fetches if any\n    self.client.lpush(self.client.getKey(self.type + ':jobs'), 1, fn || noop);\n  };\n\n  if( !this.running ) return _fn();\n  this.running = false;\n\n  // As soon as we're free, signal that we're done\n  if( !this.job ) {\n    return _fn();\n  }\n  this.on('idle', _fn);\n  this.on('job complete', _fn);\n  this.on('job failed', _fn);\n  this.on('job failed attempt', _fn);\n\n  if( timeout ) {\n    shutdownTimer = setTimeout(function() {\n      // shutdown timeout reached...\n      if( self.job ) {\n        self.drop_user_callbacks = true;\n        self.removeAllListeners();\n        if( self.job === true ) {\n          self.once('idle', _fn);\n        } else {\n          // a job is running, fail it and call _fn when failed\n          self.once('job failed', _fn);\n          self.once('job failed attempt', _fn);\n          self.failed(self.job, { error: true, message: 'Shutdown' });\n        }\n      } else {\n        // no job running, just finish immediately\n        _fn();\n      }\n    }.bind(this), timeout);\n  }\n};\n\nWorker.prototype.emitJobEvent = function( event, job, arg1, arg2 ) {\n  if( this.cleaned_up ) return;\n  events.emit(job.id, event, arg1, arg2);\n  this.emit('job ' + event, job);\n};\n\nWorker.prototype.resume = function() {\n  if( this.running ) return false;\n  this.cleaned_up          = false;\n  this.drop_user_callbacks = false;\n  this.running             = true;\n  return true;\n};\n","/home/travis/build/npmtest/node-npmtest-kue/node_modules/kue/lib/redis.js":"/*!\n * kue - RedisClient factory\n * Copyright (c) 2013 Automattic <behradz@gmail.com>\n * Copyright (c) 2011 LearnBoost <tj@learnboost.com>\n * MIT Licensed\n * Author: behradz@gmail.com\n */\n\n/**\n * Module dependencies.\n */\n\nvar redis = require('redis');\nvar url   = require('url');\n\n/**\n *\n * @param options\n * @param queue\n */\n\nexports.configureFactory = function( options, queue ) {\n  options.prefix = options.prefix || 'q';\n\n  if( typeof options.redis === 'string' ) {\n    // parse the url\n    var conn_info = url.parse(options.redis, true /* parse query string */);\n    if( conn_info.protocol !== 'redis:' ) {\n      throw new Error('kue connection string must use the redis: protocol');\n    }\n\n    options.redis = {\n      port: conn_info.port || 6379,\n      host: conn_info.hostname,\n      db: (conn_info.pathname ? conn_info.pathname.substr(1) : null) || 0,\n      // see https://github.com/mranney/node_redis#rediscreateclient\n      options: conn_info.query\n    };\n\n    if( conn_info.auth ) {\n      options.redis.auth = conn_info.auth.replace(/.*?:/, '');\n    }\n\n  }\n\n  options.redis = options.redis || {};\n\n  // guarantee that redis._client has not been populated.\n  // may warrant some more testing - i was running into cases where shutdown\n  // would call redis.reset but an event would be emitted after the reset\n  // which would re-create the client and cache it in the redis module.\n  exports.reset();\n\n  /**\n   * Create a RedisClient.\n   *\n   * @return {RedisClient}\n   * @api private\n   */\n  exports.createClient = function() {\n    var clientFactoryMethod = options.redis.createClientFactory || exports.createClientFactory;\n    var client              = clientFactoryMethod(options);\n\n    client.on('error', function( err ) {\n      queue.emit('error', err);\n    });\n\n    client.prefix           = options.prefix;\n\n    // redefine getKey to use the configured prefix\n    client.getKey = function( key ) {\n      if( client.constructor.name == 'Redis'  || client.constructor.name == 'Cluster') {\n        // {prefix}:jobs format is needed in using ioredis cluster to keep they keys in same node\n        // otherwise multi commands fail, since they use ioredis's pipeline.\n        return '{' + this.prefix + '}:' + key;\n      }\n      return this.prefix + ':' + key;\n    };\n\n    client.createFIFO = function( id ) {\n      //Create an id for the zset to preserve FIFO order\n      var idLen = '' + id.toString().length;\n      var len = 2 - idLen.length;\n      while (len--) idLen = '0' + idLen;\n      return idLen + '|' + id;\n    };\n\n    // Parse out original ID from zid\n    client.stripFIFO = function( zid ) {\n      if ( typeof zid === 'string' ) {\n        return +zid.substr(zid.indexOf('|')+1);\n      } else {\n        // Sometimes this gets called with an undefined\n        // it seems to be OK to have that not resolve to an id\n        return zid;\n      }\n    };\n\n    return client;\n  };\n};\n\n/**\n * Create a RedisClient from options\n * @param options\n * @return {RedisClient}\n * @api private\n */\n\nexports.createClientFactory = function( options ) {\n  var socket = options.redis.socket;\n  var port   = !socket ? (options.redis.port || 6379) : null;\n  var host   = !socket ? (options.redis.host || '127.0.0.1') : null;\n  var db   = !socket ? (options.redis.db || 0) : null;\n  var client = redis.createClient(socket || port, host, options.redis.options);\n  if( options.redis.auth ) {\n    client.auth(options.redis.auth);\n  }\n  if( db >= 0 ){\n    client.select(db);\n  }\n  return client;\n};\n\n/**\n * Create or return the existing RedisClient.\n *\n * @return {RedisClient}\n * @api private\n */\n\nexports.client = function() {\n  return exports._client || (exports._client = exports.createClient());\n};\n\n/**\n * Return the pubsub-specific redis client.\n *\n * @return {RedisClient}\n * @api private\n */\n\nexports.pubsubClient = function() {\n  return exports._pubsub || (exports._pubsub = exports.createClient());\n};\n\n/**\n * Resets internal variables to initial state\n *\n * @api private\n */\nexports.reset = function() {\n  exports._client && exports._client.quit();\n  exports._pubsub && exports._pubsub.quit();\n  exports._client = null;\n  exports._pubsub = null;\n};\n","/home/travis/build/npmtest/node-npmtest-kue/node_modules/kue/lib/queue/events.js":"/*!\n * kue - events\n * Copyright (c) 2013 Automattic <behradz@gmail.com>\n * Copyright (c) 2011 LearnBoost <tj@learnboost.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar redis = require('../redis');\n\n/**\n * Job map.\n */\n\nexports.jobs = {};\n\n/**\n * Pub/sub key.\n */\n\nexports.key = 'events';\n\n/**\n * Add `job` to the jobs map, used\n * to grab the in-process object\n * so we can emit relative events.\n *\n * @param {Job} job\n * @api private\n */\nexports.callbackQueue = [];\n\nexports.add = function( job, callback ) {\n  if( job.id ) {\n    if(!exports.jobs[ job.id ])\n      exports.jobs[ job.id ] = [];\n\n    exports.jobs[ job.id ].push(job);\n  }\n//  if (!exports.subscribed) exports.subscribe();\n  if( !exports.subscribeStarted ) exports.subscribe();\n  if( !exports.subscribed ) {\n    exports.callbackQueue.push(callback);\n  } else {\n    callback();\n  }\n};\n\n/**\n * Remove `job` from the jobs map.\n *\n * @param {Job} job\n * @api private\n */\n\nexports.remove = function( job ) {\n  delete exports.jobs[ job.id ];\n};\n\n/**\n * Subscribe to \"q:events\".\n *\n * @api private\n */\n\nexports.subscribe = function() {\n//  if (exports.subscribed) return;\n  if( exports.subscribeStarted ) return;\n  var client    = redis.pubsubClient();\n  client.on('message', exports.onMessage);\n  client.subscribe(client.getKey(exports.key),  function() {\n    exports.subscribed = true;\n    while( exports.callbackQueue.length ) {\n      process.nextTick(exports.callbackQueue.shift());\n    }\n  });\n  exports.queue = require('../kue').singleton;\n//  exports.subscribed = true;\n  exports.subscribeStarted = true;\n};\n\nexports.unsubscribe = function() {\n  var client               = redis.pubsubClient();\n  client.unsubscribe();\n  client.removeAllListeners();\n  exports.subscribeStarted = false;\n};\n\n/**\n * Message handler.\n *\n * @api private\n */\n\nexports.onMessage = function( channel, msg ) {\n  // TODO: only subscribe on {Queue,Job}#on()\n  msg = JSON.parse(msg);\n\n  // map to Job when in-process\n  var jobs = exports.jobs[ msg.id ];\n  if( jobs && jobs.length > 0 ) {\n    for (var i = 0; i < jobs.length; i++) {\n      var job = jobs[i];\n      job.emit.apply(job, msg.args);\n      if( [ 'complete', 'failed' ].indexOf(msg.event) !== -1 ) exports.remove(job);\n    }\n  }\n  // emit args on Queues\n  msg.args[ 0 ] = 'job ' + msg.args[ 0 ];\n  msg.args.splice(1, 0, msg.id);\n  if( exports.queue ) {\n    exports.queue.emit.apply(exports.queue, msg.args);\n  }\n};\n\n/**\n * Emit `event` for for job `id` with variable args.\n *\n * @param {Number} id\n * @param {String} event\n * @param {Mixed} ...\n * @api private\n */\n\nexports.emit = function( id, event ) {\n  var client = redis.client()\n    , msg    = JSON.stringify({\n        id: id, event: event, args: [].slice.call(arguments, 1)\n      });\n  client.publish(client.getKey(exports.key), msg, function () {});\n};\n","/home/travis/build/npmtest/node-npmtest-kue/node_modules/kue/lib/queue/job.js":"/*!\n * kue - Job\n * Copyright (c) 2013 Automattic <behradz@gmail.com>\n * Copyright (c) 2011 LearnBoost <tj@learnboost.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar EventEmitter = require('events').EventEmitter\n  , events       = require('./events')\n  , redis        = require('../redis')\n  , _            = require('lodash')\n  , util         = require('util')\n  , noop         = function() {};\n\n/**\n * Expose `Job`.\n */\n\nexports = module.exports = Job;\n\n\nexports.disableSearch = true;\n\n\nexports.jobEvents = true;\n\n/**\n * Search instance.\n */\nvar search;\nfunction getSearch() {\n  if( search ) return search;\n  var reds = require('reds');\n  reds.createClient = require('../redis').createClient;\n  return search = reds.createSearch(redis.client().getKey('search'));\n}\n\n/**\n * Default job priority map.\n */\n\nvar priorities = exports.priorities = {\n  low: 10, normal: 0, medium: -5, high: -10, critical: -15\n};\n\n/**\n * Map `jobs` by the given array of `ids`.\n *\n * @param {Object} jobs\n * @param {Array} ids\n * @return {Array}\n * @api private\n */\n\nfunction map( jobs, ids ) {\n  var ret = [];\n  ids.forEach(function( id ) {\n    if( jobs[ id ] ) ret.push(jobs[ id ]);\n  });\n  ret     = ret.sort(function( a, b ) {\n    return parseInt(a.id) - parseInt(b.id);\n  });\n  return ret;\n}\n\n/**\n * Return a function that handles fetching\n * of jobs by the ids fetched.\n *\n * @param {Function} fn\n * @param {String} order\n * @param {String} jobType\n * @return {Function}\n * @api private\n */\n\nfunction get( fn, order, jobType) {\n  return function( err, ids ) {\n    if( err ) return fn(err);\n    var pending = ids.length\n      , jobs    = {};\n    if( !pending ) return fn(null, ids);\n    ids.forEach(function( id ) {\n      id = redis.client().stripFIFO(id); // turn zid back to regular job id\n      exports.get(id, jobType, function( err, job ) {\n        if( err ) {\n          console.error(err);\n        } else {\n          jobs[ redis.client().createFIFO(job.id) ] = job;\n        }\n        --pending || fn(null, 'desc' == order\n          ? map(jobs, ids).reverse()\n          : map(jobs, ids));\n\n      });\n    });\n  }\n}\n\n/**\n * Get with the range `from`..`to`\n * and invoke callback `fn(err, ids)`.\n *\n * @param {Number} from\n * @param {Number} to\n * @param {String} order\n * @param {Function} fn\n * @api public\n */\n\nexports.range = function( from, to, order, fn ) {\n  redis.client().zrange(redis.client().getKey('jobs'), from, to, get(fn, order));\n};\n\n/**\n * Get jobs of `state`, with the range `from`..`to`\n * and invoke callback `fn(err, ids)`.\n *\n * @param {String} state\n * @param {Number} from\n * @param {Number} to\n * @param {String} order\n * @param {Function} fn\n * @api public\n */\n\nexports.rangeByState = function( state, from, to, order, fn ) {\n  redis.client().zrange(redis.client().getKey('jobs:' + state), from, to, get(fn, order));\n};\n\n/**\n * Get jobs of `type` and `state`, with the range `from`..`to`\n * and invoke callback `fn(err, ids)`.\n *\n * @param {String} type\n * @param {String} state\n * @param {Number} from\n * @param {Number} to\n * @param {String} order\n * @param {Function} fn\n * @api public\n */\n\nexports.rangeByType = function( type, state, from, to, order, fn ) {\n  redis.client().zrange(redis.client().getKey('jobs:' + type + ':' + state), from, to, get(fn, order, type));\n};\n\n/**\n * Get job with `id` and callback `fn(err, job)`.\n *\n * @param {Number} id\n * @param {String} jobType is optional\n * @param {Function} fn\n * @api public\n */\n\nexports.get = function( id, jobType, fn ) {\n  if (typeof jobType === 'function' && !fn) {\n    fn = jobType;\n    jobType = '';\n  }\n  var client = redis.client()\n    , job    = new Job;\n\n  job.id = id;\n  job.zid = client.createFIFO(id);\n  client.hgetall(client.getKey('job:' + job.id), function( err, hash ) {\n    if( err ) return fn(err);\n    if( !hash ) {\n      exports.removeBadJob(job.id, jobType);\n      return fn(new Error('job \"' + job.id + '\" doesnt exist'));\n    }\n    if( !hash.type ) {\n      exports.removeBadJob(job.id, jobType);\n      return fn(new Error('job \"' + job.id + '\" is invalid'))\n    }\n    // TODO: really lame, change some methods so\n    // we can just merge these\n    job.type              = hash.type;\n    job._ttl              = hash.ttl;\n    job._delay            = hash.delay;\n    job.priority(Number(hash.priority));\n    job._progress         = hash.progress;\n    job._attempts         = Number(hash.attempts);\n    job._max_attempts     = Number(hash.max_attempts);\n    job._state            = hash.state;\n    job._error            = hash.error;\n    job.created_at        = hash.created_at;\n    job.promote_at        = hash.promote_at;\n    job.updated_at        = hash.updated_at;\n    job.failed_at         = hash.failed_at;\n    job.started_at        = hash.started_at;\n    job.duration          = hash.duration;\n    job.workerId          = hash.workerId;\n    job._removeOnComplete = hash.removeOnComplete;\n    try {\n      if( hash.data ) job.data = JSON.parse(hash.data);\n      if( hash.result ) job.result = JSON.parse(hash.result);\n      if( hash.progress_data ) job.progress_data = JSON.parse(hash.progress_data);\n      if( hash.backoff ) {\n        var source = 'job._backoff = ' + hash.backoff + ';';\n//                require('vm').runInContext( source );\n        eval(source);\n      }\n    } catch(e) {\n      err = e;\n    }\n    fn(err, job);\n  });\n};\n\n/**\n * Remove all references to an invalid job. Will remove leaky keys in redis keys:TYPE:STATE when\n * exports.rangeByType is used.\n *\n * @param {Number} id\n * @param {String} jobType\n */\n\nexports.removeBadJob = function( id, jobType) {\n  var client = redis.client();\n  var zid = client.createFIFO(id);\n  client.multi()\n    .del(client.getKey('job:' + id + ':log'))\n    .del(client.getKey('job:' + id))\n    .zrem(client.getKey('jobs:inactive'), zid)\n    .zrem(client.getKey('jobs:active'), zid)\n    .zrem(client.getKey('jobs:complete'), zid)\n    .zrem(client.getKey('jobs:failed'), zid)\n    .zrem(client.getKey('jobs:delayed'), zid)\n    .zrem(client.getKey('jobs'), zid)\n    .zrem(client.getKey('jobs:' + jobType + ':inactive'), zid)\n    .zrem(client.getKey('jobs:' + jobType+ ':active'), zid)\n    .zrem(client.getKey('jobs:' + jobType + ':complete'), zid)\n    .zrem(client.getKey('jobs:' + jobType + ':failed'), zid)\n    .zrem(client.getKey('jobs:' + jobType + ':delayed'), zid)\n    .exec();\n  if( !exports.disableSearch ) {\n    getSearch().remove(id);\n  }\n};\n\n/**\n * Remove job `id` if it exists and invoke callback `fn(err)`.\n *\n * @param {Number} id\n * @param {Function} fn\n * @api public\n */\n\nexports.remove = function( id, fn ) {\n  fn = fn || noop;\n  exports.get(id, function( err, job ) {\n    if( err ) return fn(err);\n    if( !job ) return fn(new Error('failed to find job ' + id));\n    job.remove(fn);\n  });\n};\n\n/**\n * Get log for job `id` and callback `fn(err, log)`.\n *\n * @param {Number} id\n * @param {Function} fn\n * @return {Type}\n * @api public\n */\n\nexports.log = function( id, fn ) {\n  /*redis*/\n  Job.client/*()*/.lrange(Job.client.getKey('job:' + id + ':log'), 0, -1, fn);\n};\n\n/**\n * Initialize a new `Job` with the given `type` and `data`.\n *\n * @param {String} type\n * @param {Object} data\n * @api public\n */\n\nfunction Job( type, data ) {\n  this.type          = type;\n  this.data          = data || {};\n  this._max_attempts = 1;\n  this._jobEvents = exports.jobEvents;\n//  this.client = redis.client();\n  this.client = Job.client/* || (Job.client = redis.client())*/;\n  this.priority('normal');\n  this.on('error', function( err ) {\n  });// prevent uncaught exceptions on failed job errors\n}\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\n\nJob.prototype.__proto__ = EventEmitter.prototype;\n\n/**\n * Return JSON-friendly object.\n *\n * @return {Object}\n * @api public\n */\n\nJob.prototype.toJSON = function() {\n  return {\n    id: this.id\n    , type: this.type\n    , data: this.data\n    , result: this.result\n    , priority: this._priority\n    , progress: this._progress || 0\n    , progress_data: this.progress_data\n    , state: this._state\n    , error: this._error\n    , created_at: this.created_at\n    , promote_at: this.promote_at\n    , updated_at: this.updated_at\n    , failed_at: this.failed_at\n    , started_at: this.started_at\n    , duration: this.duration\n    , delay: this._delay\n    , workerId: this.workerId\n    , ttl: this._ttl\n    , attempts: {\n      made: Number(this._attempts) || 0\n      , remaining: this._attempts > 0 ? this._max_attempts - this._attempts : Number(this._max_attempts) || 1\n      , max: Number(this._max_attempts) || 1\n    }\n  };\n};\n\n\nJob.prototype.refreshTtl = function() {\n  ('active' === this.state() && this._ttl > 0)\n    ?\n    this.client.zadd(this.client.getKey('jobs:' + this.state()), Date.now() + parseInt(this._ttl), this.zid, noop)\n    :\n    noop();\n};\n\n\n/**\n * Log `str` with sprintf-style variable args or anything (objects,arrays,numbers,etc).\n *\n * Examples:\n *\n *    job.log('preparing attachments');\n *    job.log('sending email to %s at %s', user.name, user.email);\n *    job.log({key: 'some key', value: 10});\n *    job.log([1,2,3]);\n *\n * Specifiers:\n *\n *   - %s : string\n *   - %d : integer\n *\n * @param {String} str\n * @param {Mixed} ...\n * @return {Job} for chaining\n * @api public\n */\n\nJob.prototype.log = function( str ) {\n  if(typeof str === 'string') {\n    var formatted = util.format.apply(util, arguments);\n  }else{\n    var formatted = util.inspect(str);\n  }\n  this.client.rpush(this.client.getKey('job:' + this.id + ':log'), formatted, noop);\n  this.set('updated_at', Date.now());\n  return this;\n};\n\n/**\n * Set job `key` to `val`.\n *\n * @param {String} key\n * @param {String} val\n * @param {String} fn\n * @return {Job} for chaining\n * @api public\n */\n\nJob.prototype.set = function( key, val, fn ) {\n  this.client.hset(this.client.getKey('job:' + this.id), key, val, fn || noop);\n  return this;\n};\n\n/**\n * Get job `key`\n *\n * @param {String} key\n * @param {Function} fn\n * @return {Job} for chaining\n * @api public\n */\n\nJob.prototype.get = function( key, fn ) {\n  this.client.hget(this.client.getKey('job:' + this.id), key, fn || noop);\n  return this;\n};\n\n/**\n * Set the job progress by telling the job\n * how `complete` it is relative to `total`.\n * data can be used to pass extra data to job subscribers\n *\n * @param {Number} complete\n * @param {Number} total\n * @param {Object} data\n * @return {Job} for chaining\n * @api public\n */\n\nJob.prototype.progress = function( complete, total, data ) {\n  if( 0 == arguments.length ) return this._progress;\n  var n = Math.min(100, complete * 100 / total | 0);\n  this.set('progress', n);\n\n  // If this stringify fails because of a circular structure, even the one in events.emit would.\n  // So it does not make sense to try/catch this.\n  if( data ) this.set('progress_data', JSON.stringify(data));\n\n  this.set('updated_at', Date.now());\n  this.refreshTtl();\n  events.emit(this.id, 'progress', n, data);\n  return this;\n};\n\n/**\n * Set the job delay in `ms`.\n *\n * @param {Number|Date} delay in ms or execution date\n * @return {Job|Number}\n * @api public\n */\n\nJob.prototype.delay = function( ms ) {\n  if( 0 == arguments.length ) return this._delay;\n  if( _.isDate(ms) ) {\n    ms = parseInt(ms.getTime() - Date.now())\n  }\n  if( ms > 0 ) {\n    this._delay = ms;\n  }\n  return this;\n};\n\n/**\n * Sets the jobEvents flag for the job.\n * Can be used to override the global exports.jobEvents setting\n *\n * @param  {Boolean} events True if job events should be emitted, false if job events should not be emitted.\n * @return {Job}        Returns `this` for chaining\n */\nJob.prototype.events = function (events) {\n  this._jobEvents = !!events;\n  return this;\n};\n\nJob.prototype.removeOnComplete = function( param ) {\n  if( 0 == arguments.length ) return this._removeOnComplete;\n  this._removeOnComplete = param;\n  return this;\n};\n\nJob.prototype.backoff = function( param ) {\n  if( 0 == arguments.length ) return this._backoff;\n  this._backoff = param;\n  return this;\n};\n\n/**\n *\n * @param param\n * @returns {*}\n */\nJob.prototype.ttl = function( param ) {\n  if( 0 == arguments.length ) return this._ttl;\n  if( param > 0 ) {\n    this._ttl = param;\n  }\n  return this;\n};\n\nJob.prototype._getBackoffImpl = function() {\n  var supported_backoffs = {\n    fixed: function( delay ) {\n      return function( attempts ) {\n        return delay;\n      };\n    }\n    , exponential: function( delay ) {\n      return function( attempts ) {\n        return Math.round(delay * 0.5 * ( Math.pow(2, attempts) - 1));\n      };\n    }\n  };\n  if( _.isPlainObject(this._backoff) ) {\n    return supported_backoffs[ this._backoff.type ](this._backoff.delay || this._delay);\n  } else {\n    return this._backoff;\n  }\n};\n\n/**\n * Set or get the priority `level`, which is one\n * of \"low\", \"normal\", \"medium\", and \"high\", or\n * a number in the range of -10..10.\n *\n * @param {String|Number} level\n * @return {Job|Number} for chaining\n * @api public\n */\n\nJob.prototype.priority = function( level ) {\n  if( 0 == arguments.length ) return this._priority;\n  this._priority = null == priorities[ level ]\n    ? level\n    : priorities[ level ];\n  return this;\n};\n\n/**\n * Increment attempts, invoking callback `fn(remaining, attempts, max)`.\n *\n * @param {Function} fn\n * @return {Job} for chaining\n * @api public\n */\n\nJob.prototype.attempt = function( fn ) {\n  var client = this.client\n    , id     = this.id\n    , key    = client.getKey('job:' + id);\n\n  this._attempts = this._attempts || 0;\n  if( this._attempts < this._max_attempts ) {\n    client.hincrby(key, 'attempts', 1, function( err, attempts ) {\n      this._attempts = attempts;\n      fn(err, Math.max(0, this._max_attempts - attempts), attempts, this._max_attempts);\n    }.bind(this));\n  } else {\n    fn(null, 0, this._attempts, this._max_attempts);\n  }\n  return this;\n};\n\n\n/**\n * Try to reattempt the job seand called onFailedAttempt, or call onFailed\n * @param remaining total left attempts\n * @param attempts\n * @param onFailedAttempt\n * @param onFailed\n * @param clbk\n */\n\nJob.prototype.reattempt = function( attempts, clbk ) {\n  clbk = clbk || noop;\n  if( this.backoff() ) {\n    var delay = this.delay();\n    if( _.isFunction(this._getBackoffImpl()) ) {\n      try {\n        delay = this._getBackoffImpl().apply(this, [ attempts ]);\n      } catch(e) {\n        clbk(e);\n      }\n    }\n    var self = this;\n    this.delay(delay).update(function( err ) {\n      if( err ) return clbk(err);\n      self.delayed(clbk);\n    });\n  } else {\n    this.inactive(clbk);\n  }\n};\n\n/**\n * Set max attempts to `n`.\n *\n * @param {Number} n\n * @return {Job} for chaining\n * @api public\n */\n\nJob.prototype.attempts = function( n ) {\n  this._max_attempts = n;\n  return this;\n};\n\n\nJob.prototype.failedAttempt = function( theErr, fn ) {\n  this.error(theErr).failed(function() {\n    this.attempt(function( error, remaining, attempts/*, max*/ ) {\n      if( error ) {\n        this.emit( 'error', error );\n        return fn && fn( error );\n      }\n      if( remaining > 0 ) {\n        this.reattempt(attempts, function( err ) {\n          if( err ) {\n            this.emit( 'error', err );\n            return fn && fn( err );\n          }\n          fn && fn( err, true, attempts );\n        }.bind(this));\n      } else if( remaining === 0 )  {\n        fn && fn( null, false, attempts );\n      } else {\n        fn && fn( new Error('Attempts Exceeded') );\n      }\n    }.bind(this));\n  }.bind(this));\n  return this;\n};\n\nJob.prototype.searchKeys = function( keys ) {\n  if( 0 == arguments.length ) return this._searchKeys;\n  this._searchKeys = keys || [];\n  if( !_.isArray(this._searchKeys) ) {\n    this._searchKeys = [ this._searchKeys ];\n  }\n  return this;\n};\n\n/**\n * Remove the job and callback `fn(err)`.\n *\n * @param {Function} fn\n * @return {Job} for chaining\n * @api public\n */\n\nJob.prototype.remove = function( fn ) {\n  var client = this.client;\n  client.multi()\n    .zrem(client.getKey('jobs:' + this.state()), this.zid)\n    .zrem(client.getKey('jobs:' + this.type + ':' + this.state()), this.zid)\n    .zrem(client.getKey('jobs'), this.zid)\n    .del(client.getKey('job:' + this.id + ':log'))\n    .del(client.getKey('job:' + this.id))\n    .exec(function( err ) {\n//            events.remove(this);\n      events.emit(this.id, 'remove', this.type);\n      if( !exports.disableSearch ) {\n        getSearch().remove(this.id, fn);\n      } else {\n        fn && fn(err);\n      }\n    }.bind(this));\n  return this;\n};\n\n/**\n * Set state to `state`.\n *\n * @param {String} state\n * @param fn\n * @return {Job} for chaining\n * @api public\n */\nJob.prototype.state = function( state, fn ) {\n  if( 0 == arguments.length ) return this._state;\n  var client   = this.client\n    , fn       = fn || noop;\n  var oldState = this._state;\n  var multi    = client.multi();\n  if( oldState && oldState != '' && oldState != state ) {\n    multi\n      .zrem(client.getKey('jobs:' + oldState), this.zid)\n      .zrem(client.getKey('jobs:' + this.type + ':' + oldState), this.zid);\n  }\n  multi\n    .hset(client.getKey('job:' + this.id), 'state', state)\n    .zadd(client.getKey('jobs:' + state), this._priority, this.zid)\n    .zadd(client.getKey('jobs:' + this.type + ':' + state), this._priority, this.zid);\n\n  // use promote_at as score when job moves to delayed\n  ('delayed' === state) ? multi.zadd(client.getKey('jobs:' + state), parseInt(this.promote_at), this.zid) : noop();\n  ('active' === state && this._ttl > 0) ? multi.zadd(client.getKey('jobs:' + state), Date.now() + parseInt(this._ttl), this.zid) : noop();\n  ('active' === state && !this._ttl) ? multi.zadd(client.getKey('jobs:' + state), this._priority<0?this._priority:-this._priority, this.zid) : noop();\n  ('inactive' === state) ? multi.lpush(client.getKey(this.type + ':jobs'), 1) : noop();\n\n  this.set('updated_at', Date.now());\n  this._state = state;\n  multi.exec(function( err, replies ) {\n    if( !err ) {\n      (this._state === 'inactive') ? events.emit(this.id, 'enqueue', this.type) : noop();\n    }\n    return fn(err);\n  }.bind(this));\n  return this;\n};\n\n/**\n * Set the job's failure `err`.\n *\n * @param {Error} err\n * @return {Job} for chaining\n * @api public\n */\n\nJob.prototype.error = function( err ) {\n  var str, summary;\n  if( 0 == arguments.length ) return this._error;\n\n  if( 'string' == typeof err ) {\n    str     = err;\n    summary = '';\n  } else {\n    if( err.stack && 'string' === typeof err.stack ) {\n      str = err.stack\n    } else { //TODO what happens to CallSite[] err.stack?\n      str = err.message\n    }\n    summary = ('string' === typeof str) ? str.split('\\n')[ 0 ] : '';\n  }\n  this.set('error', str);\n  this.log('%s', summary);\n  events.emit(this.id, 'error', str);\n  return this;\n};\n\n/**\n * Set state to \"complete\", and progress to 100%.\n */\n\nJob.prototype.complete = function( clbk ) {\n  return this.set('progress', 100).state('complete', clbk);\n};\n\n/**\n * Set state to \"failed\".\n */\n\nJob.prototype.failed = function( clbk ) {\n  this.failed_at = Date.now();\n  return this.set('failed_at', this.failed_at).state('failed', clbk);\n};\n\n/**\n * Set state to \"inactive\".\n */\n\nJob.prototype.inactive = function( clbk ) {\n  return this.state('inactive', clbk);\n};\n\n/**\n * Set state to \"active\".\n */\n\nJob.prototype.active = function( clbk ) {\n  return this.state('active', clbk);\n};\n\n/**\n * Set state to \"delayed\".\n */\n\nJob.prototype.delayed = function( clbk ) {\n  return this.state('delayed', clbk);\n};\n\n/**\n * Save the job, optionally invoking the callback `fn(err)`.\n *\n * @param {Function} fn\n * @return {Job} for chaining\n * @api public\n */\n\nJob.prototype.save = function( fn ) {\n  var client = this.client\n    , fn     = fn || noop\n    , max    = this._max_attempts\n    , self   = this;\n\n  // update\n  if( this.id ) return this.update(fn);\n\n  // incr id\n  client.incr(client.getKey('ids'), function( err, id ) {\n    if( err ) return fn(err);\n    // add the job for event mapping\n    self.id = id;\n    self.zid = client.createFIFO(id);\n    self.subscribe(function() {\n      self._state     = self._state || (this._delay ? 'delayed' : 'inactive');\n      if( max ) { self.set('max_attempts', max); }\n      client.sadd(client.getKey('job:types'), self.type, noop);\n      self.set('type', self.type);\n      var now         = Date.now();\n      self.created_at = now;\n      self.set('created_at', self.created_at);\n      self.promote_at = now + (self._delay || 0);\n      self.set('promote_at', self.promote_at);\n      self.update(fn);\n    }.bind(this));\n  }.bind(this));\n  return this;\n};\n\n/**\n * Update the job and callback `fn(err)`.\n *\n * @param {Function} fn\n * @api public\n */\n\nJob.prototype.update = function( fn ) {\n  var json;\n\n  // serialize json data\n  try {\n    json = JSON.stringify(this.data);\n  } catch(err) {\n    fn(err);\n    return this;\n  }\n\n  // delay\n  if( this._delay ) {\n    this.set('delay', this._delay);\n    if( this.created_at ) {\n      var timestamp   = parseInt(this.failed_at || this.created_at, 10)\n        , delay       = parseInt(this._delay);\n      this.promote_at = timestamp + delay;\n      this.set('promote_at', this.promote_at);\n    }\n  }\n  if( this._ttl ) {\n    this.set('ttl', this._ttl);\n  }\n  if( this._removeOnComplete ) this.set('removeOnComplete', this._removeOnComplete);\n  if( this._backoff ) {\n    if( _.isPlainObject(this._backoff) ) this.set('backoff', JSON.stringify(this._backoff));\n    else this.set('backoff', this._backoff.toString());\n  }\n\n  // updated timestamp\n  this.set('updated_at', Date.now());\n  this.refreshTtl();\n\n  // priority\n  this.set('priority', this._priority);\n\n  this.client.zadd(this.client.getKey('jobs'), this._priority, this.zid, noop);\n\n  // data\n  this.set('data', json, function() {\n    // state\n    this.state(this._state, fn);\n  }.bind(this));\n\n  if( !exports.disableSearch ) {\n    if( this.searchKeys() ) {\n      this.searchKeys().forEach(function( key ) {\n        var value = _.get(this.data, key);\n        if( !_.isString(value) ) {\n          value = JSON.stringify(value);\n        }\n        getSearch().index(value, this.id);\n      }.bind(this));\n    } else {\n      getSearch().index(json, this.id);\n    }\n  }\n  return this;\n};\n\n/**\n * Subscribe this job for event mapping.\n *\n * @return {Job} for chaining\n * @api public\n */\n\nJob.prototype.subscribe = function( callback ) {\n  if( this._jobEvents ) {\n    events.add(this, callback);\n  } else {\n    callback && callback();\n  }\n  return this;\n};\n","/home/travis/build/npmtest/node-npmtest-kue/node_modules/kue/lib/queue/test_mode.js":"var Job = require('./job'),\n    _   = require('lodash');\n\nvar originalJobSave   = Job.prototype.save,\n    originalJobUpdate = Job.prototype.update,\n    processQueue,\n    jobs;\n\nfunction testJobSave( fn ) {\n  if(processQueue) {\n    jobs.push(this);\n    originalJobSave.call(this, fn);\n  } else {\n    this.id = _.uniqueId();\n    jobs.push(this);\n    if( _.isFunction(fn) ) fn();    \n  }\n};\n\nfunction testJobUpdate( fn ) {\n  if(processQueue) {\n    originalJobUpdate.call(this, fn);\n  } else {\n    if( _.isFunction(fn) ) fn();\n  }\n};\n\n/**\n * Array of jobs added to the queue\n * @api public\n */\n\nmodule.exports.jobs = jobs = [];\nmodule.exports.processQueue = processQueue = false;\n\n/**\n * Enable test mode.\n * @api public\n */\n\nmodule.exports.enter = function(process) {\n  processQueue         = process || false;\n  Job.prototype.save   = testJobSave;\n  Job.prototype.update = testJobUpdate;\n};\n\n/**\n * Disable test mode.\n * @api public\n */\n\nmodule.exports.exit = function() {\n  Job.prototype.save   = originalJobSave;\n  Job.prototype.update = originalJobUpdate;\n};\n\n/**\n * Clear the array of queued jobs\n * @api public\n */\n\nmodule.exports.clear = function() {\n  jobs.length = 0;\n};\n"}